bench
	CPUDigitsOfPi.java
package bench;

import java.math.BigDecimal;
import java.math.RoundingMode;
public class CPUDigitsOfPi implements IBenchmark{
	private int size;
	public static BigDecimal pi =  BigDecimal.ZERO;
	public static BigDecimal denom1 =  BigDecimal.ONE;
	public static BigDecimal denom2 =  BigDecimal.ONE;
	public static BigDecimal term1 =  BigDecimal.ZERO;
	public static BigDecimal term2 =  BigDecimal.ZERO;
	@SuppressWarnings("deprecation")
	public void run() {
		{
			// accuracy parameters set to 1000 arbitrarily
			for(int i=2;i<1000;i+=4)
			{
				denom1 =  BigDecimal.ONE;
				denom1 = denom1.multiply(new BigDecimal(i));
				denom1 = denom1.multiply(new BigDecimal(i+1));
				denom1 = denom1.multiply(new BigDecimal(i+2));

				denom2 =  BigDecimal.ONE;
				denom2 = denom2.multiply(new BigDecimal(i+2));
				denom2 = denom2.multiply(new BigDecimal(i+3));
				denom2 = denom2.multiply(new BigDecimal(i+4));

				// accuracy parameters set to 1000 arbitrarily
				term1 = new BigDecimal("4").divide(denom1,1000, RoundingMode.HALF_UP);
				term2 = new BigDecimal("-4").divide(denom2, 1000, RoundingMode.HALF_UP);

				pi = pi.add(term1);
				pi = pi.add(term2);
			}

			// 3 + calculated value
			pi = pi.add(new BigDecimal (3));
			System.out.println(pi);
			// user digit input applied
			pi = pi.setScale(size,  1);
			//System.out.println(pi);
			pi =  BigDecimal.ZERO;
		}
		
	}

	public void run(Object x) {
		// TODO Auto-generated method stub
		
	}

	public void initialize(int y) {
		// TODO Auto-generated method stub
		this.size = size;
	}

	public void clean() {
		// TODO Auto-generated method stub
		
	}

	public void cancel() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void warmup() {
		for(int i=2;i<1000;i+=4)
		{
			denom1 =  BigDecimal.ONE;
			denom1 = denom1.multiply(new BigDecimal(i));
			denom1 = denom1.multiply(new BigDecimal(i+1));
			denom1 = denom1.multiply(new BigDecimal(i+2));

			denom2 =  BigDecimal.ONE;
			denom2 = denom2.multiply(new BigDecimal(i+2));
			denom2 = denom2.multiply(new BigDecimal(i+3));
			denom2 = denom2.multiply(new BigDecimal(i+4));

			// accuracy parameters set to 1000 arbitrarily
			term1 = new BigDecimal("4").divide(denom1, 1000, RoundingMode.HALF_UP);
			term2 = new BigDecimal("-4").divide(denom2, 1000, RoundingMode.HALF_UP);

			pi = pi.add(term1);
			pi = pi.add(term2);
		}

		// 3 + calculated value
		pi = pi.add(new BigDecimal (3));

		// user digit input applied
		System.out.println(pi);
		pi = pi.setScale(size,  BigDecimal.ROUND_HALF_UP);
		//System.out.println(pi);
		pi =  BigDecimal.ZERO;
	}
		
}

DemoBench.java

package bench;

import java.util.Random;

public class DemoBench implements IBenchmark{
	public int n;
	public int[] array;
	public boolean running;
	public void run()
	{
		running=true;
		int x;
		for(int i=0;i<n && running;i++)
			for(int j=i;j<n && running;j++)
			{
				if(array[i]>array[j])
				{
					x=array[i];
					array[i]=array[j];
					array[j]=x;
				}
			}
	}
	public void run(Object x) 
	{
		
	}
	public void initialize(int y)
	{
		Random random = new Random();
		this.n=y;
		this.array= new int[n];
		for(int i=0;i<n;i++)
		{
			array[i]= random.nextInt(1000);
		}
	}
	public void clean()
	{
		
	}
	public void cancel()
	{
		running=false;
	}
	@Override
	public void warmup() {
		// TODO Auto-generated method stub
		
	}
}

IBenchmark.java

package bench;

public interface IBenchmark {

	void run();
	void run(Object x);
	void initialize(int y);
	void clean();
	void cancel();
	public void warmup();
}

ThreadBench.java

package bench;

import java.util.Random;

public class ThreadBench implements IBenchmark{
	public int n;
	public void run()
	{
		try {
			Thread.sleep(n);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	public void run(Object x) 
	{
		
	}
	public void initialize(int y)
	{
		this.n=y;
		
	}
	public void clean()
	{
		
	}
	public void cancel()
	{
		
	}
	@Override
	public void warmup() {
		// TODO Auto-generated method stub
		
	}
}

logging

	ConsoleLogger.java
package logging;

import java.util.concurrent.TimeUnit;

public class ConsoleLogger implements ILog{

	public static void write (long x)
	{
		System.out.println(x);
	}
	public static void write (String str)
	{
		System.out.println(str);
	}
	public static void close()
	{
		
	}
	public static void write ()
	{
		
	}
	static void writeTime(long value, TimeUnit unit)
	{
		
	}
	static void writeTime(String string, long value, TimeUnit unit)
	{
		if (unit == TimeUnit.MILLISECONDS)
			System.out.println(string+value/1000000+" Milli");
		if (unit == TimeUnit.NANOSECONDS)
			System.out.println(string+value+" NANO");
		if (unit == TimeUnit.SECONDS)
			System.out.println(string+value/1000000000+" Seconds");
		
	}
}

FileLogger.java

package logging;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
public class FileLogger implements ILog{
	String name="";
	static String FILES;
	static FileWriter myWriter=null;
	public FileLogger(String FILE)
	{

	
	    FILES=FILE;
		File file = new File(FILE);
		boolean result;  
		try   
		{  
			result = file.createNewFile();  //creates a new file  
			if(result)      // test if successfully created a new file  
			{  
				System.out.println("file created "+file.getCanonicalPath()); //returns the path string  
			}  
			else  
			{  
				System.out.println("File already exist at location: "+file.getCanonicalPath());  
			}  
		}   
			catch (IOException e)   
			{  
				e.printStackTrace();    //prints exception if any  
			}         
		  
		  

	    
	}
	public static void write (long x)
	{
	    try {
	    	String output;
	    	Long y=x;
	    	output=y.toString();
	        myWriter = new FileWriter(FILES);
	        myWriter.write(output);
	        myWriter.close();
	        System.out.println("Successfully wrote to the file.");
	      } catch (IOException e) {
	        System.out.println("An error occurred.");
	        e.printStackTrace();
	      }
	    
		  
	}
	
	public static void write (String str)
	{
	    try {
	        myWriter = new FileWriter(FILES);
	        myWriter.write((String) str);
	        myWriter.close();
	        System.out.println("Successfully wrote to the file.");
	      } catch (IOException e) {
	        System.out.println("An error occurred.");
	        e.printStackTrace();
	      }
	}
	public static void close() throws IOException
	{
		myWriter.close();
	}
	public static void write ()
	{
		
	}
}

ILog.java

package logging;

import java.util.concurrent.TimeUnit;

public interface ILog {
	static void write (long x)
	{
		
	}
	static void write (String str)
	{
		
	}
	static void writeTime(long value, TimeUnit unit)
	{
		
	}
	static void writeTime(String string, long value, TimeUnit unit)
	{
		
	}
	static void close()
	{
		
	}
	static void write()
	{
		
	}
}

testbench

	CPUBench.java

package testbench;
import java.io.IOException;

import bench.CPUDigitsOfPi;
import logging.ConsoleLogger;
import logging.FileLogger;
import timing.Timer;
public class CPUBench {
	public static void main(String[] args) throws IOException {
		Timer.start();
		CPUDigitsOfPi benchmark=new CPUDigitsOfPi();
		benchmark.initialize(9);
		benchmark.warmup();
		benchmark.initialize(9);
		benchmark.run();
		ConsoleLogger.write(Timer.stop()/1000000);
		//Offset = 100 * (Timer.totalTime - 1000*1000000) / (1000*1000000);
		//ConsoleLogger.write(Offset);
		//System.out.println(CPUDigitsOfPi.pi);
		ConsoleLogger.close();
		
	}
}

Test1.java

package testbench;

import java.io.IOException;

import bench.DemoBench;
import bench.ThreadBench;
import logging.ConsoleLogger;
import logging.FileLogger;
import timing.Timer;

public class Test1 {

	public static void main(String[] args) throws IOException {
		long Offset;
		Timer.start();
		ThreadBench benchmark=new ThreadBench();
		benchmark.initialize(1000);
		benchmark.run();
		ConsoleLogger.write(Timer.stop()/1000000);
		//Offset = 100 * (Timer.totalTime - 1000*1000000) / (1000*1000000);
		//ConsoleLogger.write(Offset);
		ConsoleLogger.close();
		
		final int workload = 100;
		benchmark.initialize(workload);
		for(int i=0;i<12;++i)
		{
			Timer.resume();
			benchmark.run();
			long time = Timer.pause();
			ConsoleLogger.write("Run "+i+":" + (time)/1000000);
		}
		ConsoleLogger.write("Finished in" + Timer.stop()/1000000);
		
		
		FileLogger x = new FileLogger("input.txt");
		FileLogger.write(0);
		FileLogger.close();
	}

}

timing
	ITimer.java

package timing;

public interface ITimer {
	static void start()
	{
		
	}
	static long stop()
	{
		return 0;
		
	}
	static void resume()
	{
		
	}
	static long pause() {
		return 0;
	}
}

Timer.java

package timing;

public class Timer implements ITimer{
	public static long start;
	public static long end;
	public static long elapsed;
	public static long totalTime;
	public static void start()
	{
		start=System.nanoTime();
		elapsed=0;
		totalTime=0;
	}
	public static long stop()
	{
		end=System.nanoTime();
		elapsed=end-start;
		totalTime=totalTime+elapsed;
		return totalTime;
	}
	public static void resume()
	{
		elapsed=0;
		start=System.nanoTime();
	}
	public static long pause()
	{
		end=System.nanoTime();
		elapsed=end-start;
		totalTime=totalTime+elapsed;
		return elapsed;
	}
}

doc
	input.txt






























																													Made by Arnold Simionica 27.03.2022
																													P.S THE GRAFICAL USER INTERFACE WAS MADE BY ARNOLD SIMIONICA TOO 27.03.2022